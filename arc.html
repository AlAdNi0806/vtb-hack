<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Real-Time Conversation</title>
  <style>
    body{font-family:Arial;display:flex;flex-direction:column;align-items:center;margin:0}
    #log{border:1px solid #ccc;width:90%;max-width:600px;height:60vh;overflow-y:auto;padding:10px}
    .user{color:#0066cc}
    .ai{color:#009900}
    button{margin:10px;padding:10px 20px;font-size:1.2em}
  </style>
</head>
<body>
  <h1>Conversation</h1>
  <div id="log"></div>
  <button id="toggleBtn">Start</button>

<script>
const SERVER_URL = 'ws://192.168.0.176:8765';
const logDiv = document.getElementById('log');
const btn    = document.getElementById('toggleBtn');

let socket, audioCtx, workletNode, stream, running=false;

/* --- AudioWorklet resampler (same as before) --- */
const workletBlob = new Blob([`
class Resampler extends AudioWorkletProcessor {
  constructor(opts){super(); this.ratio = sampleRate/16000; this.buf=new Float32Array(0)}
  process(inputs,_,__){
    const inp = inputs[0][0], len=inp.length;
    const tmp = new Float32Array(this.buf.length+len);
    tmp.set(this.buf); tmp.set(inp,this.buf.length); this.buf=tmp;
    const needed = Math.floor(this.buf.length/this.ratio);
    if(!needed) return true;
    const out=new Int16Array(needed);
    for(let i=0;i<needed;i++){
      const v=this.buf[Math.floor(i*this.ratio)];
      out[i]=v<0? v*0x8000 : v*0x7FFF;
    }
    this.buf=this.buf.slice(needed*this.ratio);
    this.port.postMessage(out.buffer);
    return true;
  }
}
registerProcessor('resampler',Resampler);
`], {type:'application/javascript'});

async function start() {
  stream = await navigator.mediaDevices.getUserMedia({audio:true});
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  const url = URL.createObjectURL(workletBlob);
  await audioCtx.audioWorklet.addModule(url);
  URL.revokeObjectURL(url);

  workletNode = new AudioWorkletNode(audioCtx,'resampler');
  const src = audioCtx.createMediaStreamSource(stream);
  src.connect(workletNode);

  socket = new WebSocket(SERVER_URL);
  socket.binaryType = 'arraybuffer';

  socket.onopen = () => {
    workletNode.port.onmessage = e => socket.send(e.data);
    btn.textContent = 'Stop';
    running=true;
  };

  socket.onmessage = e => {
    const msg = JSON.parse(e.data);
    if (msg.type === 'asr_final') append('user', msg.text);
    else if (msg.type === 'ai_partial') append('ai', msg.text, true);
    else if (msg.type === 'ai_final') append('ai', msg.text, false, true);
  };

  socket.onclose = stop;
}

function stop() {
  running=false; btn.textContent='Start';
  if(workletNode) workletNode.disconnect();
  if(stream) stream.getTracks().forEach(t=>t.stop());
  if(audioCtx) audioCtx.close();
  if(socket) socket.close();
}

function append(role,text,partial=false,final=false){
  const last = logDiv.lastElementChild;
  const cls = role==='user'?'user':'ai';
  if(partial && last && last.classList.contains(cls)){
    last.textContent = last.textContent.replace(/\s*\[.*?\]\s*$/,'') + `[${text}]`;
  }else if(partial){
    logDiv.insertAdjacentHTML('beforeend', `<div class="${cls}">[${text}]</div>`);
  }else{
    if(last && last.classList.contains(cls) && last.textContent.endsWith(']'))
      last.remove();
    logDiv.insertAdjacentHTML('beforeend', `<div class="${cls}">${text}</div>`);
  }
  logDiv.scrollTop = logDiv.scrollHeight;
}

btn.onclick = () => running? stop() : start();
</script>
</body>
</html>