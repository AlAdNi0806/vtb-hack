<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>Real-Time Streaming ASR</title>
<style>
  body {
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
  }
  #caption {
    border: 1px solid #ccc;
    padding: 12px;
    margin-top: 20px;
    width: 80%;
    min-height: 120px;
    white-space: pre-wrap;
    background: #f9f9f9;
    font-size: 1.1em;
    line-height: 1.5em;
  }
  button {
    font-size: 1.2em;
    padding: 10px 24px;
    margin: 10px;
    border: none;
    border-radius: 6px;
    background: #0078d7;
    color: white;
    cursor: pointer;
  }
  button:hover {
    background: #005ea1;
  }
  .segment-time {
    color: #555;
    font-size: 0.9em;
  }
</style>
</head>
<body>
  <h1>Real-Time Speech-to-Text</h1>
  <button id="toggleBtn">Start</button>
  <div id="caption">Press Start to begin…</div>

<script>
const SERVER_URL = 'ws://192.168.0.176:8765';   // <-- adjust to your server
const toggleBtn  = document.getElementById('toggleBtn');
const captionDiv = document.getElementById('caption');

let audioCtx, mediaStream, socket, workletNode;
let running = false;

/* === Embedded Worklet for resampling === */
const workletCode = `
class Resampler extends AudioWorkletProcessor {
  constructor(options) {
    super();
    this.targetRate = options.processorOptions.targetRate || 16000;
    this.ratio = sampleRate / this.targetRate;
    this.buffer = new Float32Array(0);
  }
  process(inputs) {
    const input = inputs[0][0];
    if (!input) return true;

    const old = this.buffer;
    this.buffer = new Float32Array(old.length + input.length);
    this.buffer.set(old);
    this.buffer.set(input, old.length);

    const needed = Math.floor(this.buffer.length / this.ratio);
    if (!needed) return true;

    const out = new Int16Array(needed);
    for (let i = 0; i < needed; ++i) {
      const idx = Math.floor(i * this.ratio);
      const s = this.buffer[idx];
      out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }
    this.buffer = this.buffer.slice(needed * this.ratio);
    this.port.postMessage(out.buffer);
    return true;
  }
}
registerProcessor('resampler', Resampler);
`;

/* === Main logic === */
toggleBtn.onclick = async () => {
  if (running) await stop();
  else         await start();
};

async function start() {
  try {
    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const blob = new Blob([workletCode], { type: 'application/javascript' });
    const url  = URL.createObjectURL(blob);
    await audioCtx.audioWorklet.addModule(url);
    URL.revokeObjectURL(url);

    workletNode = new AudioWorkletNode(audioCtx, 'resampler',
                                       { processorOptions: { targetRate: 16000 } });
    const source = audioCtx.createMediaStreamSource(mediaStream);
    source.connect(workletNode);

    socket = new WebSocket(SERVER_URL);
    socket.binaryType = 'arraybuffer';

    socket.onopen = () => {
      workletNode.port.onmessage = e => {
        if (socket.readyState === WebSocket.OPEN)
          socket.send(e.data);
      };
      toggleBtn.textContent = 'Stop';
      captionDiv.textContent = 'Listening…';
      running = true;
    };

    socket.onmessage = e => {
      const { transcript, segments, is_final } = JSON.parse(e.data);
      if (is_final && transcript) {
        let html = "";
        if (segments && segments.length > 0) {
          for (const seg of segments) {
            html += `<div><span class="segment-time">[${seg.start.toFixed(1)}s–${seg.end.toFixed(1)}s]</span> ${seg.segment}</div>`;
          }
        } else {
          html += transcript + " ";
        }
        captionDiv.innerHTML += html;
        captionDiv.scrollTop = captionDiv.scrollHeight;
      }
    };

    socket.onclose = stop;
  } catch(err) {
    alert("Error: " + err);
  }
}

async function stop() {
  running = false;
  toggleBtn.textContent = 'Start';
  if (workletNode)  workletNode.disconnect();
  if (mediaStream)  mediaStream.getTracks().forEach(t => t.stop());
  if (audioCtx)     audioCtx.close();
  if (socket && socket.readyState === WebSocket.OPEN) socket.close();
}
</script>
</body>
</html>
